import subprocess, os
from dataclasses import dataclass
from typing import Dict



    
@dataclass
class PATH_DIR:
    file_name : str
    file_path : str 
    

## checks is a file is executable:
def is_executable(dir_env_path:PATH_DIR):
    are_executable =[]
    
    for ex in dir_env_path.executables:
        full_path = dir_env_path.file_path +"/"+ ex
        #print(ex.file_path)
        if os.path.isfile(full_path) and os.access(full_path, os.X_OK):
            #print(f"executable name : {ex}")
            are_executable.append(full_path)
        #else:
            #print(f"is not : {full_path}")

    return are_executable
    

def extract_executables(dir_path:PATH_DIR):
    ls_dir = "".join(["ls ", f"{dir_path.file_path}"])
    dir_list = subprocess.check_output(ls_dir, shell=True, text=True)
    dir_content = dir_list.split('\n')
    cleaned_dir_content = dir_content[1:len(dir_content)-1]
    dir_path.executables = cleaned_dir_content
    ready_to_go_exec = is_executable(dir_path)
    
    dir_path.executables = ready_to_go_exec
    #print(dir_path.executables) 
    return dir_path
    
    



## checks for hidden dir, files:
def filter_hidden(dir):
    non_hidden = []
    
    
    for ddir in dir:
        seperated_dir = (ddir.split('/')[-1]).strip()
        pth = ddir
        hidden =  seperated_dir.startswith(".") 
        if hidden:
            print(f"this d:{seperated_dir} is hidden")
            continue
        else:
            n_d = PATH_DIR(file_name = seperated_dir,file_path=  pth)
            if n_d in non_hidden:
                print(f"[-][-] - {n_d} already there ")
                continue
            else:
                non_hidden.append(n_d)
            #print(non_hidden[-1])
    #print(non_hidden)
    return non_hidden


def extrcating_executables():

    valid_executables = []
    cmd = "echo $PATH"
    path_env = subprocess.check_output(cmd, text=True, shell=True)
    list_of_dir = path_env.split(":")

    filtered = filter_hidden(list_of_dir)
    #print(filtered)
    for di in filtered:
        execu = extract_executables(di)
        
        if execu.executables:
            [valid_executables.append(executable) for executable in execu.executables]


    return valid_executables




def extracting_writeables():
    try:
        # Tries to run the command and checks for status 0 (Success)
        ss = subprocess.check_output("find / -writable 2>/dev/null", shell=True, text=True)
        print("[[--]] extracting writables ----_______-----")
        #print("Command executed successfully (Status 0):\n", ss)
        print("---- Command executed successfully (Status 0) ----")
        return ss
        #if ss:

        
    except subprocess.CalledProcessError as e:
        # Catches the error when the exit status is non-zero (e.g., Status 1)
        print("--- CalledProcessError Caught ---")
        print(f"Command returned non-zero exit status {e.returncode}.")
        print("However, the command's standard output was captured (partial or full list):")
        
        # Access the output generated by the command before the error
        outp = e.output
        print("[[--]] extracting writables ----_______-----")
        return outp
  #      print("------- output finished ----------")
        
    except Exception as e:
        # Catch any other unexpected errors
        print(f"An unexpected error occurred: {e}", file=sys.stderr)

    
        
    
    


if __name__ == "__main__":


    valid_exec = extrcating_executables()
    writeables = extracting_writeables().split('\n')
    s_valid_exec = set(valid_exec)
    s_writeables = set(writeables)
    hh = ['/bin/zdump', '/bin/zegrep']
    sh = ['/bin/zdump', '/etc/grep']
    shh = set(hh)
    shs = set(sh)
    intersection = s_valid_exec.intersection(s_writeables)
    if intersection:
        print("[[--]] here are the common executbales : -----")
        print(intersection)
    else:
        print("[[--]] None intersections were found ...")

    
    #extracting_writeables()

