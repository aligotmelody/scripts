import subprocess, os
from dataclasses import dataclass
from typing import Dict
import concurrent.futures



    
@dataclass
class PATH_DIR:
    file_name : str
    file_path : str 
    

## checks if a file is executable:
def is_executable(dir_env_path:PATH_DIR):
    are_executable =[]
    
    for ex in dir_env_path.executables:
        full_path = dir_env_path.file_path +"/"+ ex
        
        if os.path.isfile(full_path) and os.access(full_path, os.X_OK):
            
            are_executable.append(full_path)
       

    return are_executable
    

def extract_executables(dir_path:PATH_DIR):
   
    #ls_dir = os.listdir(dir_path.file_path)
    ls_dir = "".join(["ls ", f"{dir_path.file_path}"])
    
    dir_list = subprocess.check_output(ls_dir, shell=True, text=True)
    dir_content = dir_list.split('\n')
    cleaned_dir_content = dir_content[1:len(dir_content)-1]
    dir_path.executables = cleaned_dir_content
    ready_to_go_exec = is_executable(dir_path)
    
    dir_path.executables = ready_to_go_exec
    
    
    return dir_path
    
    



## filters out hidden dir, files:
def filter_hidden(dir):
    non_hidden = []
    
    
    for ddir in dir:
        seperated_dir = (ddir.split('/')[-1]).strip()
        pth = ddir
        hidden =  seperated_dir.startswith(".") 
        if hidden:
            print(f"this d:{seperated_dir} is hidden")
            continue
        else:
            n_d = PATH_DIR(file_name = seperated_dir,file_path=  pth)
            if n_d in non_hidden:
                print(f"[-][-] - {n_d} already there ")
                continue
            else:
                non_hidden.append(n_d)
            
    
    return non_hidden


def extrcating_executables():
    print("[1] starting extracting_executables")

    valid_executables = []
    cmd = "echo $PATH"
    path_env = subprocess.check_output(cmd, text=True, shell=True)
    list_of_dir = path_env.split(":")

    filtered = filter_hidden(list_of_dir)
    
    for di in filtered:
        execu = extract_executables(di)
        
        if execu.executables:
            [valid_executables.append(executable) for executable in execu.executables]
    print("[2] finished extracting_executables")


    return valid_executables




def extracting_writeables():
    try:
        # Tries to run the command and checks for status 0 (Success)
        ss = subprocess.check_output("find /home /tmp /var /bin /usr /root -writable 2>/dev/null", shell=True, text=True)
        print("[[--]] extracting writables ----_______-----")
        #print("Command executed successfully (Status 0):\n", ss)
        print("---- Command executed successfully (Status 0) ----")
        return ss
        #if ss:

        
    except subprocess.CalledProcessError as e:
        # Catches the error when the exit status is non-zero (e.g., Status 1)
        print("--- CalledProcessError Caught ---")
        print(f"Command returned non-zero exit status {e.returncode}.")
        print("However, the command's standard output was captured (partial or full list):")
        
        # Access the output generated by the command before the error
        outp = e.output
        print("[[--]] extracting writables ----_______-----")
        return outp
  #      print("------- output finished ----------")
        
    except Exception as e:
        # Catch any other unexpected errors
        print(f"An unexpected error occurred: {e}", file=sys.stderr)
        return

    
        
    
    


if __name__ == "__main__":
   with concurrent.futures.ThreadPoolExecutor(max_workers=2) as executor:
        futures = {
            executor.submit(extrcating_executables): "exec",
            executor.submit(extracting_writeables): "write"
        }

        results = {}

        for future in concurrent.futures.as_completed(futures):
            tag = futures[future]
            results[tag] = future.result()

        exec_result = results["exec"]
        exec_writables = results["write"].split("\n")
        
        if exec_result and exec_writables:
            s_valid_exec = set(exec_result)
            s_writeables = set(exec_writables)

            intersection = s_valid_exec.intersection(s_writeables)
            if intersection:
                print("[[--]] here are the common executbales : -----")
                for intersect in intersection:
                    print(intersect, end='\n')
            else:
                print("[[--]] No intersections were found ...")
        else:
            print("[[-!!-]] Either or both functions ran into a problem")
        
        

